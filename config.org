#+TITLE: Kidrigger's Literate GNU Emacs Config
#+AUTHOR: Anish Bhobe
#+EMAIL: anishbhobe@hotmail.com
#+STARTUP: show2levels
#+TOC: headlines 2

* Initial
** Package Manager (Elpaca)

Straight from the Elpaca README

#+BEGIN_SRC emacs-lisp
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
				:ref nil :depth 1
				:files (:defaults "elpaca-test.el" (:exclude "extensions"))
				:build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
	 (build (expand-file-name "elpaca/" elpaca-builds-directory))
	 (order (cdr elpaca-order))
	 (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
	  (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
		   ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
						   ,@(when-let ((depth (plist-get order :depth)))
						       (list (format "--depth=%d" depth) "--no-single-branch"))
						   ,(plist-get order :repo) ,repo))))
		   ((zerop (call-process "git" nil buffer t "checkout"
					 (or (plist-get order :ref) "--"))))
		   (emacs (concat invocation-directory invocation-name))
		   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
					 "--eval" "(byte-recompile-directory \".\" 0 'force)")))
		   ((require 'elpaca))
		   ((elpaca-generate-autoloads "elpaca" repo)))
	      (progn (message "%s" (buffer-string)) (kill-buffer buffer))
	    (error "%s" (with-current-buffer buffer (buffer-string))))
	((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+END_SRC

Removing symlinking for windows and ms-dos, while rest can symlink

#+BEGIN_SRC emacs-lisp
  (when (member system-type '(ms-dos windows-nt))
    (elpaca-no-symlink-mode))
#+END_SRC

Setting up elpaca use-package support.

#+BEGIN_SRC emacs-lisp
  (elpaca elpaca-use-package
	  (elpaca-use-package-mode))
  ;; Block until complete
  (elpaca-wait)
#+END_SRC

** No Littering
Emacs creates a lot of (useful) garbage everywhere ~file~~, ~#file#~, and ~$HOME~ etc. (eww)
~no-littering~ helps keep our noses clean.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :ensure t
    :demand t)
#+END_SRC

** Default Settings
*** Remove UI Elements
I don't need the menus etc. I'll use the shortcuts everywhere.

Emacs toolbar is pretty old.
It makes Notepad++ look modern :eww:
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

No use for scroll bar when we use line numbers.
That's some free real estate.
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
#+END_SRC

File Open dialog is suppressed. Might want to suppress all dialog boxes later.
#+BEGIN_SRC emacs-lisp
  (setq use-file-dialog nil)
  ; (setq use-dialog-box nil)
#+END_SRC

*** Saved Customizations
I don't want my ~init.el~ to be polluted by the saved customizations from emacs.
Adding all that to a separate ~customizations.el~ file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "customizations.el" user-emacs-directory))
#+END_SRC

*** Startup Configuration
Don't want a startup message.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
  :init
  (setq initial-scratch-message nil)
  (defun display-startup-echo-area-message ()
    (message "")))
#+END_SRC

The splash screen is kinda cringe. Might change it later though.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

*** Allow Y/N instead of Yes/No
How hard is it to really make simplicity default?

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (defalias 'yes-or-no-p 'y-or-n-p))
#+END_SRC

*** Use UTF-8 everywhere

#+BEGIN_SRC emacs-lisp
  (use-package emacs
  :init
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8
        coding-system-for-read 'utf-8
        coding-system-for-write 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix)))
#+END_SRC

*** Use spaces but configure tab-width
Go mode needs tabs. Use spaces otherwise.
I don't think I'll ever use ~golang~ but it never hurts to be safe.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (setq-default indent-tabs-mode nil)
    (setq-default tab-width 4))
#+END_SRC

*** Do not show invalid options in M-x
Emacs 28 and newer: Hide commands in M-x which do not work in the current mode.

#+BEGIN_SRC emacs-lisp
  (setq read-extended-command-predicate #'command-completion-default-include-p)
#+END_SRC

*** No cursors in minibuffer prompt

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
  #+END_SRC

*** Recursive Minibuffer
Support opening new minibuffers from inside existing minibuffers.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

*** CRM Indicator

#+BEGIN_SRC emacs-lisp
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
  #+END_SRC
* Keybinding
** Normal Generic Bindings
Some bindings for random things that will make sense in context of Meow for usability.

~SPC w (C-c w)~ to write instead of ~SPC x s (C-x C-s)~
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind
    (:map mode-specific-map
          ("w" . save-buffer)))
#+END_SRC
** Meow
Modal editing is superior to ...whatever the hell emacs has.
Meow is nice, not as weird as evil.
*** Command Layout
Meow is keybind agnostic so we use QWERTY command layout default. (For now)

#+BEGIN_SRC emacs-lisp
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     '("u" . meow-universal-argument)
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . consult-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("/" . consult-line)
     '("?" . consult-ripgrep)
     '(":" . consult-goto-line)
     '("'" . repeat)
     '("<escape>" . ignore)))
#+END_SRC

*** Installation and Config

Actually install ~meow~ and set it up.
For the reasons of /correctness/, we must wait after, in order to ensure all the next packages bind correctly.

#+BEGIN_SRC emacs-lisp
  (use-package meow
    :ensure t
    :demand t
    :custom
    (meow-keypad-self-insert-undefined nil)
    :config
    (meow-setup)
    (meow-global-mode 1))

  (elpaca-wait)
#+END_SRC

* RICE
** Font config
Fonts are rather important to how things look
Then add ~unicode-fonts~ to fill up the rest.

#+BEGIN_SRC emacs-lisp
  (use-package unicode-fonts
    :ensure t
    :demand t 
    :config
    (unicode-fonts-setup))
#+END_SRC

First, set these up.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "FiraCode Nerd Font")
  (set-face-attribute 'italic nil :family "JetBrainsMono NF" :slant 'italic :underline nil)
  (set-face-attribute 'mode-line nil :family "FiraCode Nerd Font" :weight 'bold)
  (set-face-attribute 'variable-pitch nil :family "FiraCode Nerd Font")
#+END_SRC

*** Font Test
Regular
/Italic/
*Bold*
_Underline_
~code~
+StrikeThrough+
=verbatim=
:emoji:

** Theme (Catpuccin)
Catpuccing really looks nice, so that shall be the main for now.

#+BEGIN_SRC emacs-lisp
  (use-package catppuccin-theme
    :ensure t
    :demand t
    :config
    (load-theme 'catppuccin :no-confirm))
#+END_SRC

** Modeline (Mood-line)
Using ~mood-line~ because it looks pretty. Testing
*** Modal Notations

Make each of the modal states show up as color bold 3-letter text
#+BEGIN_SRC emacs-lisp
  (setq mood-line-segment-modal-meow-state-alist
        '((normal . ("NOR" . font-lock-variable-name-face))
          (insert . ("INS" . font-lock-string-face))
          (keypad . ("KEY" . font-lock-keyword-face))
          (beacon . ("BCN" . font-lock-type-face))
          (motion . ("MOT" . font-lock-constant-face))))
#+END_SRC

*** Install Config

Install Mood Line and configure the format etc.
#+BEGIN_SRC emacs-lisp
  (use-package mood-line
    :ensure t
    :demand t
    :config
    (mood-line-mode)
    (set-face-attribute 'mode-line nil :family "JetBrainsMono Nerd Font Mono" :weight 'bold)
    :custom
    (mood-line-glyph-alist mood-line-glyphs-fira-code)
    (mood-line-format
     (mood-line-defformat
      :left
      ("  " (mood-line-segment-modal) " "
       (or (mood-line-segment-buffer-status)
           (mood-line-segment-client)
           " ")
       " "
       (and (mood-line-segment-project) "/") (mood-line-segment-buffer-name)
       "  "
       (mood-line-segment-anzu)
       "  "
       (mood-line-segment-multiple-cursors)
       "  "
       (mood-line-segment-cursor-position)
       ""
       #(" " 0 1
         (face mood-line-unimportant))
       (mood-line-segment-region)
       " "
       (mood-line-segment-scroll))
      :right
      ((mood-line-segment-indentation)
       "  "
       (mood-line-segment-eol)
       "  "
       (mood-line-segment-encoding)
       "  "
       (mood-line-segment-vc)
       "  "
       (mood-line-segment-major-mode)
       "  "
       (mood-line-segment-misc-info)
       "  "
       (when (mood-line-segment-checker) " | ")
       (mood-line-segment-checker)
       "  "
       (mood-line-segment-process)))))
#+END_SRC

* General Emacs Task Packages
** Project.el
Using updated ~project.el~ instead of the built-in one.
But will use customized roots instead of the ~vc~ based ones.

Based on [[https://andreyor.st/posts/2022-07-16-project-el-enhancements/][this blog]] about enhancements.

These are the list of files to look out for as ~root~

#+BEGIN_SRC emacs-lisp
  (defcustom project-root-markers
    '("Cargo.toml" ; Rust
      "SConstruct" ; C/C++
      "project.clj"; Clojure
      ".git" )     ; Else
    "Files or directories that indicate the root of a project."
    :type '(repeat string)
    :group 'project)
#+END_SRC

Predicate for finding project root.

#+BEGIN_SRC emacs-lisp
  (defun project-root-p (path)
    "Check if the current PATH has any of the project root markers."
    (catch 'found
      (dolist (marker project-root-markers)
        (when (file-exists-p (concat path marker))
          (throw 'found marker)))))
#+END_SRC

Function that finds project root.
NOTE: ~locate-dominating-file~ can find a file or predicate in the path upwards.

#+BEGIN_SRC emacs-lisp
  (defun project-find-root (path)
    "Search up the PATH for `project-root-markers'."
    (when-let ((root (locate-dominating-file path #'project-root-p)))
      (cons 'transient (expand-file-name root))))
#+END_SRC

Finally, update ~project.el~ and configure bindings.
~project-prefix-map~ somehow doesn't let me bind correctly as a keymap. /lame/

#+BEGIN_SRC emacs-lisp
  (use-package project
    :ensure t
    :bind
    (("C-c p p" . project-switch-project)
     ("C-c p f" . project-find-file)
     ("C-c p b" . consult-project-buffer)
     ("C-c p d" . project-dired))
    :config
    (add-to-list 'project-find-functions #'project-find-root))
#+END_SRC

** Source Control (Magit)
Well, I use Magit. It just works!

But first, I need to upgrade ~transient~ in case the old one gives a BT.

#+BEGIN_SRC emacs-lisp
  (use-package transient
    :ensure t
    :demand t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    (("C-M-g" . magit-status))
    :config
    (define-key magit-mode-map "!" 'magit-dispatch))
#+END_SRC

** Completion
*** In-place Completion (Corfu)
~corfu~ is COmpletion in Region FUnction.
This provides in-buffer completion.

~TAB~ only completion is better since sometimes I need ~RET~ despite not wanting a completion.

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :ensure t
    :init
    (global-corfu-mode)
    :custom
    (corfu-auto t)
    (corfu-preselect 'directory)
    (confu-quit-no-match 'separator)
    :bind
    (:map corfu-map
          ("RET" . nil)))
#+END_SRC

We will also need to redo the autocomplete with the ~TAB~.
Indentation and autocomplate both use ~TAB~ key. We don't want to do ~ALT TAB~ for that.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+END_SRC

*** Interactive Completion (Vertico)
Using vertico to provide eager completion for the minibuffer options.
Without vertico, I need to input, press TAB, hope it is right and then rinse and repeat.
Vertico just provides interactive feedback. Also, frequency based completion.

First, install vertico, and it should be always on.
#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :ensure t
    :demand t
    :init
    (vertico-mode))
#+END_SRC

Vertico will also need ~savehist~ to keep the history between sessions.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC

*** Option Information (Marginalia)
Vertico lacks the information of what each command does. I'm a ~noob~ so I need to know what each option does :P
So marginalia provides that bit of documentation.
This pairs with [[*Interactive Completion (Vertico)][Vertico]]

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))
#+END_SRC

*** Preview (Consult)
It's better to see before you do something.
Secondly, it's better to have my buffers and bookmarks etc be opened from the same panel since I can't even remeber where I put my beers.

*TODO(Bob):* Can add more bindings to consult commands. e.g. ~consult-line~, ~meow-visit~

~consult-line~ -> "/"
~consult-ripgrep~ -> "?"
~consult-goto-line~ -> "X" and ":"

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (("C-c b" . consult-buffer)
     ("C-x C-b" . consult-buffer)))
#+END_SRC

*** Orderless searching (Orderless)
Currently things try matching from the start, in-order.
~orderless~ matches on a word-by-word basis.
i.e.
#+BEGIN_EXAMPLE
insta carg
#+END_EXAMPLE

can match with

#+BEGIN_EXAMPLE
cargo install
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

** Checking
*** Syntax Checking (Flycheck)
Inline and hover responses to errors in my code.
Obviously I'd hate to see any but truth is difficult to swallow.

Also, configuring the binding for the ~eglot~ code action that will inevitably follow.

#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :bind
      (("C-c e e" . consult-flycheck)
       ("C-c e a" . eglot-code-actions))
      :init
      (global-flycheck-mode))
#+END_SRC

I'm using ~consult~ so ofc, I need to integrate ~flycheck~ in it.

#+BEGIN_SRC emacs-lisp
  (use-package consult-flycheck
    :ensure t)
#+END_SRC

* Use-specific configs
** Org Mode

Org mode is a gem to write all kinds of markup. Including this file XD
*** Org Settings
Basic settings that use some of the ligatures and glyphs from the nerdfonts.
This will look nice.
#+BEGIN_SRC emacs-lisp
  (setq
   ;; Edit settings
   org-auto-align-tags nil
   org-tags-column 0
   org-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t

   ;; Org styling, hide markup etc.
   org-hide-emphasis-markers t
   org-pretty-entities t
   org-ellipsis "…"

   org-agenda-tags-column 0
   org-agenda-block-separator ?─
   org-agenda-time-grid
   '((daily today require-timed)
     (800 1000 1200 1400 1600 1800 2000)
     " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
   org-agenda-current-time-string
   "◀── now ─────────────────────────────────────────────────")

#+END_SRC

*** Org Modern
Make org belong to the current era.

*Note:* ~org-modern~ indentation is a bit broken for the source blocks. Thus, a simple solution:
#+BEGIN_SRC emacs-lisp
     (use-package org-modern-indent
      :ensure (org-modern-indent :type git :host github :repo "jdtsmith/org-modern-indent")
      :config
      (add-hook 'org-mode-hook #'org-modern-indent-mode 90)
      (setq org-startup-indented t))
#+END_SRC

Finally, ~org-modern~ to actually add all the prettyfication
#+BEGIN_SRC emacs-lisp
  (use-package org-modern
    :ensure t
    :hook
    '((org-mode . org-modern-mode)
      (org-agenda-finalize . org-modern-agenda))
    :custom
    (org-modern-hide-starts nil)
    (org-modern-table nil)
    (org-modern-list
     '((?* . "•")
       (?+ . "‣")))
    (set-face-attribute 'org-modern-symbol nil :family "JetBrainsMono Nerd Font"))
#+END_SRC

** Org Roam

While ~org-roam~ does heavily use ~org-mode~, it deserves its own category since the featureset is that much special.

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/Documents/org"))
    (org-roam-database-connector 'sqlite-builtin)
    (org-roam-capture-templates
        '(("m" "main" plain
           "%?"
           :if-new (file+head "main/${slug}.org"
                              "#+title: ${title}\n")
           :immediate-finish t
           :unnarrowed t)))     
    (org-roam-node-display-template
     (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    :init
    (org-roam-db-autosync-mode)
    :config
    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (error ""))))
#+END_SRC

** Rust

So, ~rust~ is one of my favorite languages, so obviously, it has to be installed.
There are two options, ~rust-mode~ and ~rustic-mode~.

Since I've decided to use ~eglot~, ~rust-mode~ is preferred (and plays nice.)
Perhaps if it causes me pain, I'll switch it later.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    ;; :custom
    ;; (rust-mode-treesitter-derive t)
    :hook
    (rust-mode . (lambda ()
                   (setq flycheck-checker 'rust-clippy)
                   (eglot-ensure)
                   (setq indent-tabs-mode nil))))
#+END_SRC

Next, I need ~cargo-mode~ so that I can just build and execute from inside emacs.
Really, who wants to leave emacs?

Somehow, ~cargo-mode~ doesn't contain ~cargo run~. Ofcourse, I want it. So I want to add a custom keymap.
Luckily, ~rust-mode~ already contains a good way to run. Will just add that function to the keymap.
#+BEGIN_SRC emacs-lisp
  (defcustom cargo-mode-command-run "run"
    "Subcommand used by `cargo-mode-run'."
    :type 'string
    :group 'cargo-mode)

  (defun cargo-mode-run (&optional prefix)
    "Run the `cargo run` command.
    If PREFIX is non-nil, prompt for additional params."
      (interactive "P")
      (let ((project-root (cargo-mode--project-directory)))
        (cargo-mode--start "execute" cargo-mode-command-run project-root prefix)))
#+END_SRC

Finally, I actually can configure this package, with additional ~define-key~ to add ~cargo run~ into the keymap.
Need to custom bind ~cargo-mode-command-map~ to ~C-c a~ because meow doesn't seem to pick it up
(It's bound directly instead of to the ~mode-specific-map~

#+BEGIN_SRC emacs-lisp
  (use-package cargo-mode
    :ensure t
    :hook
    (rust-mode . cargo-minor-mode)
    :bind (("C-c a" . cargo-mode-command-map)
           :map cargo-mode-command-map
           ("r" . cargo-mode-run))
    :custom
    (cargo-mode-use-comint nil)
    (compilation-scroll-output t))
#+END_SRC

** Nix
Since I've started to realize how well a reliable system like NixOS can handle my stuff, the ~nix~ language definitely needs support.

First, Install the beautiful ~nix-mode~ package.
I won't be using ~nix~ outside ~NixOS~.
So, I have no need to install ~nil~ and ~nix-mode~ on those.

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :ensure t
    :if (executable-find "nil")
    :after eglot
    :hook
    (nix-mode . eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs '(nix-mode . ("nil"))))
#+END_SRC
