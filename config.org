
#+TITLE: Kidrigger's Literate GNU Emacs Config
#+AUTHOR: Anish Bhobe
#+EMAIL: anishbhobe@hotmail.com
#+STARTUP: show2levels
#+TOC: headlines 2

* Initial
** Package Manager (Elpaca)

Straight from the Elpaca README

#+BEGIN_SRC emacs-lisp
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
				:ref nil :depth 1
				:files (:defaults "elpaca-test.el" (:exclude "extensions"))
				:build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
	 (build (expand-file-name "elpaca/" elpaca-builds-directory))
	 (order (cdr elpaca-order))
	 (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
	  (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
		   ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
						   ,@(when-let ((depth (plist-get order :depth)))
						       (list (format "--depth=%d" depth) "--no-single-branch"))
						   ,(plist-get order :repo) ,repo))))
		   ((zerop (call-process "git" nil buffer t "checkout"
					 (or (plist-get order :ref) "--"))))
		   (emacs (concat invocation-directory invocation-name))
		   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
					 "--eval" "(byte-recompile-directory \".\" 0 'force)")))
		   ((require 'elpaca))
		   ((elpaca-generate-autoloads "elpaca" repo)))
	      (progn (message "%s" (buffer-string)) (kill-buffer buffer))
	    (error "%s" (with-current-buffer buffer (buffer-string))))
	((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+END_SRC

Removing symlinking for windows and ms-dos, while rest can symlink

#+BEGIN_SRC emacs-lisp
  (when (member system-type '(ms-dos windows-nt))
    (elpaca-no-symlink-mode))
#+END_SRC

Setting up elpaca use-package support.

#+BEGIN_SRC emacs-lisp
  (elpaca elpaca-use-package
	  (elpaca-use-package-mode))
  ;; Block until complete
  (elpaca-wait)
#+END_SRC

** No Littering
Emacs creates a lot of (useful) garbage everywhere ~file~~, ~#file#~, and ~$HOME~ etc. (eww)
~no-littering~ helps keep our noses clean.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :ensure t
    :demand t
    :config
    (no-littering-theme-backups))
#+END_SRC

** Default Settings
*** Remove UI Elements
I don't need the menus etc. I'll use the shortcuts everywhere.

Emacs toolbar is pretty old.
It makes Notepad++ look modern :eww:
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

No use for scroll bar when we use line numbers.
That's some free real estate.
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
#+END_SRC

File Open dialog is suppressed. Might want to suppress all dialog boxes later.
#+BEGIN_SRC emacs-lisp
  (setq use-file-dialog nil)
  ; (setq use-dialog-box nil)
#+END_SRC

*** Saved Customizations
I don't want my ~init.el~ to be polluted by the saved customizations from emacs.
Adding all that to a separate ~customizations.el~ file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "customizations.el" user-emacs-directory))
#+END_SRC

*** Startup Configuration
Don't want a startup message.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
  :init
  (setq initial-scratch-message nil)
  (defun display-startup-echo-area-message ()
    (message "")))
#+END_SRC

The splash screen is kinda cringe. Might change it later though.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

*** Allow Y/N instead of Yes/No
How hard is it to really make simplicity default?

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (defalias 'yes-or-no-p 'y-or-n-p))
#+END_SRC

*** Use UTF-8 everywhere

#+BEGIN_SRC emacs-lisp
  (use-package emacs
  :init
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8
        coding-system-for-read 'utf-8
        coding-system-for-write 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix)))
#+END_SRC

*** Use spaces but configure tab-width
Go mode needs tabs. Use spaces otherwise.
I don't think I'll ever use ~golang~ but it never hurts to be safe.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (setq-default indent-tabs-mode nil)
    (setq-default tab-width 4))
#+END_SRC

*** Do not show invalid options in M-x
Emacs 28 and newer: Hide commands in M-x which do not work in the current mode.

#+BEGIN_SRC emacs-lisp
  (setq read-extended-command-predicate #'command-completion-default-include-p)
#+END_SRC

*** No cursors in minibuffer prompt

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
  #+END_SRC

*** Recursive Minibuffer
Support opening new minibuffers from inside existing minibuffers.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

*** CRM Indicator

#+BEGIN_SRC emacs-lisp
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
  #+END_SRC
* Keybinding
** Normal Generic Bindings
Some bindings for random things that will make sense in context of Meow for usability.

~SPC w~ as a prefix for window management.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind
    (:map mode-specific-map
          ("w r" . split-window-right)
          ("w d" . split-window-below)
          ("w x" . delete-window)
          ("w w" . other-window)))
#+END_SRC

** Meow
Modal editing is superior to ...whatever the hell emacs has.
Meow is nice, not as weird as evil.
*** Command Layout
Meow is keybind agnostic so we use QWERTY command layout default. (For now)

#+BEGIN_SRC emacs-lisp
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '(":" . meow-M-x)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     '("u" . meow-universal-argument)
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . consult-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("/" . consult-line)
     '("?" . consult-ripgrep)
     '(":" . meow-M-x)
     '("'" . repeat)
     '("<escape>" . ignore)))
#+END_SRC

*** Installation and Config

Actually install ~meow~ and set it up.
For the reasons of /correctness/, we must wait after, in order to ensure all the next packages bind correctly.

#+BEGIN_SRC emacs-lisp
  (use-package meow
    :ensure t
    :demand t
    :custom
    (meow-keypad-leader-dispatch "C-c")
    (meow-keypad-self-insert-undefined nil)
    :config
    (meow-setup)
    (meow-global-mode 1))

  (elpaca-wait)
#+END_SRC

* RICE
** Layout Theming
*** Transparency
Lightly transparent stuff always looks cool, especially when you also have blur.

#+BEGIN_SRC emacs-lisp
  (set-frame-parameter (selected-frame) 'alpha-background 90)
  (add-to-list 'default-frame-alist '(alpha-background . 90))
#+END_SRC

*** Frame
Looks nicer to have a little border from the extremities.

#+begin_src emacs-lisp
  (set-frame-parameter (selected-frame) 'internal-border-width 20)
  (add-to-list 'default-frame-alist '(internal-border-width . 20))
#+end_src

** Font config
Fonts are rather important to how things look
Then add ~unicode-fonts~ to fill up the rest.

#+BEGIN_SRC emacs-lisp
  (use-package unicode-fonts
    :ensure t
    :demand t 
    :config
    (unicode-fonts-setup))
#+END_SRC

First, set these up.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "FiraCode Nerd Font")
  (set-face-attribute 'italic nil :family "JetBrainsMono NF" :slant 'italic :underline nil)
  (set-face-attribute 'mode-line nil :family "FiraCode Nerd Font" :weight 'bold)
  (set-face-attribute 'variable-pitch nil :family "FiraCode Nerd Font")
#+END_SRC

Ain't beauty delicious? Don't we want pretty things?
Some want pearls, some want cars, me, I want /ligatures/.

*NOTE:* Only for _FiraCode Nerd Font_.

#+BEGIN_SRC emacs-lisp
  (use-package ligature
    :ensure t
    :config
    ;; All modes
    (ligature-set-ligatures 't '("www" "->" "<-" "=>" "<->" "<=>" "<=" ">=" "!=" "..."
                                 ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))))
    ;; Programming only
    (ligature-set-ligatures 'prog-mode
                            '(;; == === ==== => =| =>>=>=|=>==>> ==< =/=//=// =~
                              ;; =:= =!=
                              ("=" (rx (+ (or ">" "<" "|" "/" "~" ":" "!" "="))))
                              ;; ;; ;;;
                              (";" (rx (+ ";")))
                              ;; && &&&
                              ("&" (rx (+ "&")))
                              ;; !! !!! !. !: !!. != !== !~
                              ("!" (rx (+ (or "=" "!" "\." ":" "~"))))
                              ;; ?? ??? ?:  ?=  ?.
                              ("?" (rx (or ":" "=" "\." (+ "?"))))
                              ;; %% %%%
                              ("%" (rx (+ "%")))
                              ;; |> ||> |||> ||||> |] |} || ||| |-> ||-||
                              ;; |->>-||-<<-| |- |== ||=||
                              ;; |==>>==<<==<=>==//==/=!==:===>
                              ("|" (rx (+ (or ">" "<" "|" "/" ":" "!" "}" "\]"
                                              "-" "=" ))))
                              ;; \\ \\\ \/
                              ("\\" (rx (or "/" (+ "\\"))))
                              ;; ++ +++ ++++ +>
                              ("+" (rx (or ">" (+ "+"))))
                              ;; :: ::: :::: :> :< := :// ::=
                              (":" (rx (or ">" "<" "=" "//" ":=" (+ ":"))))
                              ;; // /// //// /\ /* /> /===:===!=//===>>==>==/
                              ("/" (rx (+ (or ">"  "<" "|" "/" "\\" "\*" ":" "!"
                                              "="))))
                              ;; .. ... .... .= .- .? ..= ..<
                              ("\." (rx (or "=" "-" "\?" "\.=" "\.<" (+ "\."))))
                              ;; -- --- ---- -~ -> ->> -| -|->-->>->--<<-|
                              ("-" (rx (+ (or ">" "<" "|" "~" "-"))))
                              ;; *> */ *)  ** *** ****
                              ("*" (rx (or ">" "/" ")" (+ "*"))))
                              ;; www wwww
                              ("w" (rx (+ "w")))
                              ;; <> <!-- <|> <: <~ <~> <~~ <+ <* <$ </  <+> <*>
                              ;; <$> </> <|  <||  <||| <|||| <- <-| <-<<-|-> <->>
                              ;; <<-> <= <=> <<==<<==>=|=>==/==//=!==:=>
                              ;; << <<< <<<<
                              ("<" (rx (+ (or "\+" "\*" "\$" "<" ">" ":" "~"  "!"
                                              "-"  "/" "|" "="))))
                              ;; >: >- >>- >--|-> >>-|-> >= >== >>== >=|=:=>>
                              ;; >> >>> >>>>
                              (">" (rx (+ (or ">" "<" "|" "/" ":" "=" "-"))))
                              ;; #: #= #! #( #? #[ #{ #_ #_( ## ### #####
                              ("#" (rx (or ":" "=" "!" "(" "\?" "\[" "{" "_(" "_"
                                           (+ "#"))))
                              ;; ~~ ~~~ ~=  ~-  ~@ ~> ~~>
                              ("~" (rx (or ">" "=" "-" "@" "~>" (+ "~"))))
                              ;; __ ___ ____ _|_ __|____|_
                              ("_" (rx (+ (or "_" "|"))))
                              ;; Fira code: 0xFF 0x12
                              ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))
                              ;; Fira code:
                              "Fl"  "Tl"  "fi"  "fj"  "fl"  "ft"
                              ;; The few not covered by the regexps.
                              "{|"  "[|"  "]#"  "(*"  "}#"  "$>"  "^="))
    (global-ligature-mode t))
#+END_SRC

*** Font/Ligature Test
Regular
/Italic/
*Bold*
_Underline_
~code~
+StrikeThrough+
=verbatim=
:keyword:
Ligature != -> => ... ;; 0x124 0xA1C3E

** Theme (Catpuccin)

I'm using ~meow~ for keybinds. It will be *wrong* to use anything but ~catpuccin~ for the theme.
~catpuccin~ looks nice too, so that shall be the main for now.

#+BEGIN_SRC emacs-lisp
  (use-package catppuccin-theme
    :ensure t
    :demand t
    :config
    (load-theme 'catppuccin :no-confirm))
#+END_SRC

** Modeline (Mood-line)

Using ~mood-line~ because it looks pretty. Testing
Modify the modeline faces with reversed background and foreground.

#+begin_src emacs-lisp
  (defun kr-inverted-color (face)
    (list :background (face-foreground face)
          :foreground (face-background 'mode-line)))
#+end_src

Make the modes 3 letter words with the inverted faces.
Install Mood Line and configure the format etc.

#+BEGIN_SRC emacs-lisp
  (use-package mood-line
    :ensure t
    :demand t
    :after catppuccin-theme
    :config
    (mood-line-mode)
    :custom
    (mood-line-segment-modal-meow-state-alist
          `((normal . (" NOR " . ,(kr-inverted-color font-lock-function-name-face)))
            (insert . (" INS " . ,(kr-inverted-color font-lock-string-face)))
            (keypad . (" KEY " . ,(kr-inverted-color font-lock-keyword-face)))
            (beacon . (" BCN " . ,(kr-inverted-color font-lock-type-face)))
            (motion . (" MOT " . ,(kr-inverted-color font-lock-constant-face)))))
    (mood-line-glyph-alist mood-line-glyphs-fira-code)
    (mood-line-format
     (mood-line-defformat
      :padding ""
      :left
      ((mood-line-segment-modal) " "
       (or (mood-line-segment-buffer-status)
           (mood-line-segment-client)
           " ")
       #(" " 0 1
         (face mood-line-unimportant))
       ((mood-line-segment-project) . "/")
       (mood-line-segment-buffer-name)
       " "
       ((mood-line-segment-anzu) . " ")
       ((mood-line-segment-multiple-cursors) . " ")
       (mood-line-segment-cursor-position)
       #(" " 0 1
         (face mood-line-unimportant))
       (mood-line-segment-region)
       " "
       (mood-line-segment-scroll))
      :right
      (((mood-line-segment-vc) . " ")
       (mood-line-segment-major-mode)
       " "
       ((mood-line-segment-misc-info) . " ")
       ((mood-line-segment-checker) . " ")
       (mood-line-segment-process)))))
#+END_SRC

* General Emacs Task Packages
** Dashboard

A little nice dashboard to be shown at startup.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :hook ((elpaca-after-init . dashboard-insert-startupify-lists)
           (elpaca-after-init . dashboard-initialize))
    :custom
    (initial-buffer-choice (lambda ()
                             (get-buffer-create dashboard-buffer-name)))
    (dashboard-banner-logo-title "Kidrigger's Emacs!")
    (dashboard-startup-banner 2)
    (dashboard-footer-messages '("“Whatever you are, be a good one.” Abraham Lincoln"
                                 "“Yesterday is history, Tomorrow is a mystery, but today is a gift. That is why it is called the present.” Master Oogway"
                                 "“Man, never made any material as resilient as the human spirit.” Bernard Williams"
                                 "“I didn’t fail the test. I just found 100 ways to do it wrong.” Benjamin Franklin"
                                 "“A person who never made a mistake never tried anything new.” Albert Einstein"
                                 "“No matter what people tell you, words and ideas can change the world.” Robin Williams"
                                 "“Be yourself; everyone else is already taken.” Oscar Wilde"
                                 "“Time is a created thing. To say, “I don’t have time”, is like saying, “I don’t want to.” Lao Tzu"
                                 "“Never regret anything that made you smile.” Mark Twain"
                                 "“No act of kindness, no matter how small, is ever wasted.” Aesop"
                                 "“May your choices reflect your hopes, not your fears.” Nelson Mandela"))
    (dashboard-center-content t)
    (dashboard-vertically-center-content t)
    :config
    (dashboard-setup-startup-hook))
#+END_SRC

** Project.el
Using updated ~project.el~ instead of the built-in one.
But will use customized roots instead of the ~vc~ based ones.

Based on [[https://andreyor.st/posts/2022-07-16-project-el-enhancements/][this blog]] about enhancements.

These are the list of files to look out for as ~root~

#+BEGIN_SRC emacs-lisp
  (defcustom project-root-markers
    '("Cargo.toml" ; Rust
      "compile_commands.json" ; clangd c/c++
      "SConstruct" ; C/C++
      "project.clj"; Clojure
      ".git" )     ; Else
    "Files or directories that indicate the root of a project."
    :type '(repeat string)
    :group 'project)
#+END_SRC

Predicate for finding project root.

#+BEGIN_SRC emacs-lisp
  (defun project-root-p (path)
    "Check if the current PATH has any of the project root markers."
    (catch 'found
      (dolist (marker project-root-markers)
        (when (file-exists-p (concat path marker))
          (throw 'found marker)))))
#+END_SRC

Function that finds project root.
NOTE: ~locate-dominating-file~ can find a file or predicate in the path upwards.

#+BEGIN_SRC emacs-lisp
  (defun project-find-root (path)
    "Search up the PATH for `project-root-markers'."
    (when-let ((root (locate-dominating-file path #'project-root-p)))
      (cons 'transient (expand-file-name root))))
#+END_SRC

Finally, update ~project.el~ and configure bindings.
~project-prefix-map~ somehow doesn't let me bind correctly as a keymap. /lame/

#+BEGIN_SRC emacs-lisp
  (use-package project
    :bind
    (("C-c p p" . project-switch-project)
     ("C-c p f" . project-find-file)
     ("C-c p b" . consult-project-buffer)
     ("C-c p d" . project-dired))
    :config
    (add-to-list 'project-find-functions #'project-find-root))
#+END_SRC

** Treemacs

#+begin_src emacs-lisp
    (use-package treemacs
    :ensure t
    :defer t
    :config
      (setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay        0.5
            treemacs-directory-name-transformer      #'identity
            treemacs-display-in-side-window          t
            treemacs-eldoc-display                   'simple
            treemacs-file-event-delay                2000
            treemacs-file-extension-regex            treemacs-last-period-regex-value
            treemacs-file-follow-delay               0.2
            treemacs-file-name-transformer           #'identity
            treemacs-follow-after-init               t
            treemacs-expand-after-init               t
            treemacs-find-workspace-method           'find-for-file-or-pick-first
            treemacs-git-command-pipe                ""
            treemacs-goto-tag-strategy               'refetch-index
            treemacs-header-scroll-indicators        '(nil . "^^^^^^")
            treemacs-hide-dot-git-directory          t
            treemacs-indentation                     2
            treemacs-indentation-string              " "
            treemacs-is-never-other-window           nil
            treemacs-max-git-entries                 5000
            treemacs-missing-project-action          'ask
            treemacs-move-files-by-mouse-dragging    t
            treemacs-move-forward-on-expand          nil
            treemacs-no-png-images                   nil
            treemacs-no-delete-other-windows         t
            treemacs-project-follow-cleanup          nil
            treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-position                        'left
            treemacs-read-string-input               'from-child-frame
            treemacs-recenter-distance               0.1
            treemacs-recenter-after-file-follow      nil
            treemacs-recenter-after-tag-follow       nil
            treemacs-recenter-after-project-jump     'always
            treemacs-recenter-after-project-expand   'on-distance
            treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
            treemacs-project-follow-into-home        nil
            treemacs-show-cursor                     nil
            treemacs-show-hidden-files               t
            treemacs-silent-filewatch                nil
            treemacs-silent-refresh                  nil
            treemacs-sorting                         'alphabetic-asc
            treemacs-select-when-already-in-treemacs 'move-back
            treemacs-space-between-root-nodes        t
            treemacs-tag-follow-cleanup              t
            treemacs-tag-follow-delay                1.5
            treemacs-text-scale                      nil
            treemacs-user-mode-line-format           nil
            treemacs-user-header-line-format         nil
            treemacs-wide-toggle-width               70
            treemacs-width                           35
            treemacs-width-increment                 1
            treemacs-width-is-initially-locked       t
            treemacs-workspace-switch-cleanup        nil)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))

      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple)))

      (treemacs-hide-gitignored-files-mode t)
    :bind
    ("C-c p w"   . treemacs-select-window)
    ("C-c p x"   . treemacs-delete-other-windows)
    ("C-c p t"   . treemacs)
    ;; ("C-c p F" . treemacs-find-tag)
    ;; ("c-c p s" . treemacs-find-file)
    ("C-c p D"   . treemacs-select-directory)
    ("c-c p b"   . treemacs-bookmark))

  (use-package treemacs-icons-dired
    :hook (dired-mode . treemacs-icons-dired-enable-once)
    :ensure t)

  (use-package treemacs-magit
    :after (treemacs magit)
    :ensure t)
#+end_src

** Source Control (Magit)
Well, I use Magit. It just works!

But first, I need to upgrade ~transient~ in case the old one gives a BT.

#+BEGIN_SRC emacs-lisp
  (use-package transient
    :ensure t
    :demand t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    (("C-M-g" . magit-status))
    :config
    (define-key magit-mode-map "!" 'magit-dispatch))
#+END_SRC

** Completion
*** In-place Completion (Corfu)
~corfu~ is COmpletion in Region FUnction.
This provides in-buffer completion.

~TAB~ only completion is better since sometimes I need ~RET~ despite not wanting a completion.

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :ensure t
    :init
    (global-corfu-mode)
    :custom
    (corfu-auto t)
    (corfu-preselect 'directory)
    (confu-quit-no-match 'separator)
    :bind
    (:map corfu-map
          ("RET" . nil)))
#+END_SRC

We will also need to redo the autocomplete with the ~TAB~.
Indentation and autocomplate both use ~TAB~ key. We don't want to do ~ALT TAB~ for that.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+END_SRC

*** Interactive Completion (Vertico)
Using vertico to provide eager completion for the minibuffer options.
Without vertico, I need to input, press TAB, hope it is right and then rinse and repeat.
Vertico just provides interactive feedback. Also, frequency based completion.

First, install vertico, and it should be always on.
#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :ensure t
    :demand t
    :init
    (vertico-mode))
#+END_SRC

Vertico will also need ~savehist~ to keep the history between sessions.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC

*** Option Information (Marginalia)
Vertico lacks the information of what each command does. I'm a ~noob~ so I need to know what each option does :P
So marginalia provides that bit of documentation.
This pairs with [[*Interactive Completion (Vertico)][Vertico]]

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))
#+END_SRC

*** Preview (Consult)
It's better to see before you do something.
Secondly, it's better to have my buffers and bookmarks etc be opened from the same panel since I can't even remeber where I put my beers.

*TODO(Bob):* Can add more bindings to consult commands. e.g. ~consult-line~, ~meow-visit~

~consult-line~ -> "/"
~consult-ripgrep~ -> "?"
~consult-goto-line~ -> "X" and ":"

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (("C-c b" . consult-buffer)
     ("C-x C-b" . consult-buffer)))
#+END_SRC

*** Orderless searching (Orderless)
Currently things try matching from the start, in-order.
~orderless~ matches on a word-by-word basis.
i.e.
#+BEGIN_EXAMPLE
insta carg
#+END_EXAMPLE

can match with

#+BEGIN_EXAMPLE
cargo install
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

** Checking
*** Syntax Checking (Flycheck)
Inline and hover responses to errors in my code.
Obviously I'd hate to see any but truth is difficult to swallow.

Also, configuring the binding for the ~eglot~ code action that will inevitably follow.

#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :bind
      (("C-c e e" . consult-flycheck)
       ("C-c e a" . eglot-code-actions))
      :init
      (global-flycheck-mode))
#+END_SRC

Also, combine them together ~eglot~ to ~flycheck~ is a 'tricky' situation. So use a package.

#+begin_src emacs-lisp
  (use-package flycheck-eglot
    :ensure t
    :after (flycheck eglot)
    :config
    (global-flycheck-eglot-mode 1))
#+end_src

I'm using ~consult~ so ofc, I need to integrate ~flycheck~ in it.

#+BEGIN_SRC emacs-lisp
  (use-package consult-flycheck
    :ensure t)
#+END_SRC

* Use-specific configs
** Org Mode

Org mode is a gem to write all kinds of markup. Including this file XD
All the bindings are as follows

Prefix ~SPC n~
+ ~i~ Capture
+ ~c~ Roam Capture
+ ~r~ Roam Refile
+ ~b~ Roam Buffer Toggle
+ ~j~ Daily Journal
+ ~f~ Find Node
+ ~l~ Roam forward links
+ ~L~ Roam backward links
+ ~s~ Search

#+begin_src emacs-lisp
  (setq org-directory (file-truename "~/Documents/org"))
#+end_src

*** Org Capture Templates

#+begin_src emacs-lisp
  (use-package org-mode
    :bind ("C-c n i" . org-capture) 
    :custom
    (org-capture-templates
     '(("s" "Scheduled" entry (file "agenda/main.org")
        "* TODO %?\nSCHEDULED:<%(org-read-date)>")
       ("d" "Deadline" entry (file "agenda/main.org")
       "* TODO %?\nDEADLINE:<%(org-read-date)>")
       ("t" "TODO" entry (file "agenda/main.org")
        "* TODO %?\n")
       ("i" "Inbox" entry (file "inbox.org")
        "* %?\n:PROPERTIES:\n#+DATE:%(current-time-string)\n:END:\n"))))
#+end_src

*** Org Settings
Basic settings that use some of the ligatures and glyphs from the nerdfonts.
This will look nice.

#+BEGIN_SRC emacs-lisp
  (setq
   ;; Edit settings
   org-auto-align-tags nil
   org-tags-column 0
   org-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t

   ;; Org styling, hide markup etc.
   org-hide-emphasis-markers t
   org-pretty-entities t
   org-ellipsis "…")
#+END_SRC

Bind ~org-create-table~ to easy to access command maps.

#+begin_src emacs-lisp
  (use-package org-mode
    :bind (:map org-mode-map
           ("C-c t c" . org-table-create)
           ("C-c t a" . org-table-align)))
#+end_src

*** Org Modern
Make org belong to the current era.

Finally, ~org-modern~ to actually add all the prettyfication
#+BEGIN_SRC emacs-lisp
  (use-package org-modern
    :ensure t
    :hook
    '((org-mode . org-modern-mode)
      (org-agenda-finalize . org-modern-agenda))
    :custom
    (org-modern-hide-starts nil)
    (org-modern-table nil)
    (org-modern-list
     '((?* . "•")
       (?+ . "‣")))
    (set-face-attribute 'org-modern-symbol nil :family "JetBrainsMono Nerd Font"))
#+END_SRC

#+begin_src emacs-lisp
  (use-package org-mode
    :hook
    (org-mode . org-num-mode))
#+end_src

*** Org Tempo

Write the source blocks in one go!

#+begin_src emacs-lisp
  (use-package org-tempo)
#+end_src

*** Org Agenda

Setup a single ~org-agenda~ file so that it is easy to manage.

#+begin_src emacs-lisp
  (use-package org-agenda
    :custom
    (org-agenda-tags-column 0)
    (org-agenda-block-separator ?─)
    (org-agenda-time-grid
     '((daily today require-timed)
      (800 1000 1200 1400 1600 1800 2000)
      " ┄┄┄┄┄ " " ┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
    (org-agenda-current-time-string
     "◀── now ─────────────────────────────────────────────────")
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-files (mapcar #'file-truename '("~/Documents/org/agenda/" "~/Documents/org/inbox.org")))
    :bind
    ("C-c o A" . org-agenda))
#+end_src

** Org Roam

While ~org-roam~ does heavily use ~org-mode~, it deserves its own category since the featureset is that much special.

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/Documents/org"))
    (org-roam-database-connector 'sqlite-builtin)
    (org-roam-capture-templates
        '(("m" "main" plain
           "%?"
           :if-new (file+head "main/${slug}.org"
                              "#+title: ${title}\n")
           :immediate-finish t
           :unnarrowed t)
          ("r" "reference" plain
           "%?"
           :if-new (file+head "reference/${title}.org"
                              "#+title: ${title}\n")
           :immediate-finish t
           :unnarrowed t)))
    (org-roam-node-display-template
     (concat "${type:10} ${title:*} " (propertize "${tags:20}" 'face 'org-tag)))
    :init
    (org-roam-db-autosync-mode)
    :bind (:map mode-specific-map
                ("n c" . org-roam-capture)
                ("n r" . org-roam-refile)
                ("n b" . org-roam-buffer-toggle)
                ("n j" . org-roam-dailies-capture-today)) 
    :config
    (org-roam-db-autosync-mode)
    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (error ""))))
#+END_SRC

*** Consult Integration

#+begin_src emacs-lisp
  (use-package consult-org-roam
    :ensure t
    :after org-roam
    :custom
    (consult-org-roam-grep-func #'consult-ripgrep)
    ;; Configure a custom narrow key for `consult-buffer'
    (consult-org-roam-buffer-narrow-key ?r)
    ;; Display org-roam buffers right after non-org-roam buffers
    ;; in consult-buffer (and not down at the bottom)
    (consult-org-roam-buffer-after-buffers t)
    :config
    (consult-org-roam-mode 1)
    ;; Eventually suppress previewing for certain functions
    (consult-customize
     consult-org-roam-forward-links
     :preview-key "M-.")
    :bind (:map mode-specific-map
    ;; Define some convenient keybindings as an addition
                ("n f" . consult-org-roam-file-find)
                ("n L" . consult-org-roam-backlinks)
                ("n B" . consult-org-roam-backlinks-recursive)
                ("n l" . consult-org-roam-forward-links)
                ("n s" . consult-org-roam-search)))
#+end_src

** Prog Mode

General Programming modes.

#+begin_src emacs-lisp
  (use-package prog-mode
    :hook
    (prog-mode . display-line-numbers-mode))
#+end_src

** C/C++

Good ol' ~c~ and ~c++~. These beasts are not going anywhere.
Unlike the rest, there's no need for ~c-mode~ and ~c++-mode~ packages to be installed.
So the configuration will occur on ~eglot~'s dime.

Configuring this to work with CMake

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :hook
    ((c-mode c++-mode) . eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs `((c-mode c++-mode) "clangd")))
#+END_SRC

Refactoring support

#+begin_src emacs-lisp
  (use-package srefactor
    :ensure t
    :bind (:map c-mode-map
                ("C-<return>" . srefactor-refactor-at-point)
           :map c++-mode-map
                ("C-<return>" . srefactor-refactor-at-point))
    :config
    (semantic-mode 1))
  
#+end_src

** Java

You can hate it, you can love it, but you can not avoid it.
(But you might skip the lsp...)

Will look for the ~jdtls~ LSP server before init.

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :if (executable-find "jdtls")
    :hook
    (java-mode . eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs '(java-mode "jdtls")))
#+END_SRC

** Rust

So, ~rust~ is one of my favorite languages, so obviously, it has to be installed.
There are two options, ~rust-mode~ and ~rustic-mode~.

Since I've decided to use ~eglot~, ~rust-mode~ is preferred (and plays nice.)
Perhaps if it causes me pain, I'll switch it later.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    ;; :custom
    ;; (rust-mode-treesitter-derive t)
    :hook
    (rust-mode . (lambda ()
                   (setq flycheck-checker 'rust-clippy)
                   (eglot-ensure)
                   (setq indent-tabs-mode nil))))
#+END_SRC

Next, I need ~cargo-mode~ so that I can just build and execute from inside emacs.
Really, who wants to leave emacs?

Somehow, ~cargo-mode~ doesn't contain ~cargo run~. Ofcourse, I want it. So I want to add a custom keymap.
Luckily, ~rust-mode~ already contains a good way to run. Will just add that function to the keymap.
#+BEGIN_SRC emacs-lisp
  (defcustom cargo-mode-command-run "run"
    "Subcommand used by `cargo-mode-run'."
    :type 'string
    :group 'cargo-mode)

  (defun cargo-mode-run (&optional prefix)
    "Run the `cargo run` command.
    If PREFIX is non-nil, prompt for additional params."
      (interactive "P")
      (let ((project-root (cargo-mode--project-directory)))
        (cargo-mode--start "execute" cargo-mode-command-run project-root prefix)))
#+END_SRC

Finally, I actually can configure this package, with additional ~define-key~ to add ~cargo run~ into the keymap.
Need to custom bind ~cargo-mode-command-map~ to ~C-c a~ because meow doesn't seem to pick it up
(It's bound directly instead of to the ~mode-specific-map~

#+BEGIN_SRC emacs-lisp
  (use-package cargo-mode
    :ensure t
    :hook
    (rust-mode . cargo-minor-mode)
    :bind (:map cargo-mode-map
           ("C-c a" . cargo-mode-command-map)
           :map cargo-mode-command-map
           ("r" . cargo-mode-run))
    :custom
    (cargo-mode-use-comint nil)
    (rust-format-on-save t)
    (compilation-scroll-output t))
#+END_SRC

** Nix
Since I've started to realize how well a reliable system like NixOS can handle my stuff, the ~nix~ language definitely needs support.

First, Install the beautiful ~nix-mode~ package.
I won't be using ~nix~ outside ~NixOS~.
So, I have no need to install ~nil~ and ~nix-mode~ on those.

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :ensure t
    :if (executable-find "nil")
    :after eglot
    :hook
    (nix-mode . eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs '(nix-mode . ("nil"))))
#+END_SRC

** Common Lisp (CLISP)

I have quite fallen into love with this language. Really, this is the absolute definition of [[https://tenor.com/view/spy-x-family-elegant-elegance-gif-3561089886890940443][Elegant!]]

With the REPL and everything, it is best to use ~sly~ with ~roswell~ as the underlying setup.
Specifically, I'll be using ~sbcl~, but under ~roswell~ since that allows me to install and use other ~common-lisp~ implementations.

But I hardly ever manage to do these uniformly, so I'll create a set of fallbacks.

#+BEGIN_SRC emacs-lisp
  (setq kr-clisp-impl
        (or (let ((ros-path (executable-find "ros")))
              (when ros-path
                (format "%s dynamic-space-size=2048 -Q run" ros-path)))
            (executable-find "sbcl")))
#+END_SRC

Configure ~sly~ if we do have a ~common-lisp~ implementation. Also, the ~sly~ REPL should open when in the mode.

#+BEGIN_SRC emacs-lisp
  (use-package sly
    :ensure t
    :if kr-clisp-impl
    :hook
    (sly-mode . (lambda ()
                  (unless (sly-connected-p)
                    (save-excursion (sly)))))
    :custom
    (inferior-lisp-program kr-clisp-impl))
#+END_SRC

** Zotero Integration

Zotero is nice for managing everything.
Documentation for the plugin is [[https://github.com/emacsmirror/zotxt][here]]

#+begin_src emacs-lisp
  (use-package zotxt
    :ensure t)
#+end_src

Adds the bindings on prefix
~SPC "~
+ ~i~ Insert
+ ~u~ Update
+ ~a~ Open
